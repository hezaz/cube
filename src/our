#include "cub3d.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

void    error_and_exit(char *message)
{
    printf("Error\n%s\n", message);
    exit(1);
}

int is_valid_character(char c)
{
    return (c == '0' || c == '1' || c == 'N' || c == 'S' || c == 'E' || c == 'W' || c == ' ');
}

void check_map(t_map *map_data)
{
    int y;
    int x;
    char **map = map_data->map;
    int height = map_data->height;
    int max_width = 0;

    // Calculate the maximum width of the map
    for (y = 0; y < height; y++)
    {
        int line_length = ft_strlen(map[y]);
        if (line_length > max_width)
            max_width = line_length;
    }

    // Check top border
    for (x = 0; x < max_width; x++)
    {
        if (map[0][x] != '1' && map[0][x] != ' ' && map[0][x] != '\0' && map[0][x] != '\n')
		{
			ft_printf("%c", map[0][x]);
            error_and_exit("Map is not closed at top border");
		}
    }

    // Check bottom border
    for (x = 0; x < max_width; x++)
    {
        if (map[height - 1][x] != '1' && map[height - 1][x] != ' ' && map[height - 1][x] != '\0' && map[height - 1][x] != '\n')
            error_and_exit("Map is not closed at bottom border");
    }

    // Check left and right borders
    for (y = 0; y < height; y++)
    {
        int width = ft_strlen(map[y]);
        if (width > 0 && (map[y][0] != '1' && map[y][0] != ' '))
            error_and_exit("Map is not closed at left border");
        if (width > 1)
        {
            int rightmost_non_space = width - 1;
            while (rightmost_non_space > 0 && (map[y][rightmost_non_space] == ' ' || map[y][rightmost_non_space] == '\n'))
                rightmost_non_space--;
            if (map[y][rightmost_non_space] != '1')
                error_and_exit("Map is not closed at right border");
        }
    }

    // Check inner part of the map
    for (y = 1; y < height - 1; y++)
    {
        for (x = 1; map[y][x] != '\0'; x++)
        {
            if (map[y][x] == '0' || map[y][x] == 'N' || map[y][x] == 'S' || map[y][x] == 'E' || map[y][x] == 'W')
            {
                if (map[y - 1][x] == ' ' || map[y + 1][x] == ' ' || map[y][x - 1] == ' ' || map[y][x + 1] == ' ' ||
                    map[y - 1][x] == '\0' || map[y + 1][x] == '\0' || map[y][x - 1] == '\0' || map[y][x + 1] == '\0')
                    error_and_exit("Map is not closed around spaces");
            }
        }
    }
	ft_printf("\nallgood\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   display_2d.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: baptistevieilhescaze <baptistevieilhesc    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/19 16:34:34 by bvieilhe          #+#    #+#             */
/*   Updated: 2024/07/18 16:49:04 by baptistevie      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	draw_tile(int x, int y, int color, t_game *data)
{
	int	tile_width;
	int	tile_height;
	int	i;
	int	j;

	tile_width = 30;
	tile_height = 30;
	i = x * tile_width;
	while (i < tile_width * (x + 1))
	{
		j = y * tile_height;
		while (j < tile_height * (y + 1))
		{
			if (i + 1 == tile_width * (x + 1)
				|| j + 1 == tile_height * (y + 1))
				img_pix_put(&data->img, i, j, BLACK_PIXEL);
			else
				img_pix_put(&data->img, i, j, color);
			j++;
		}
		i++;
	}
}

void	draw_map(t_game *data)
{
	int	i;
	int	j;

	print_map(data->map);
	
	i = 0;
	while (i < data->map->height)
	{
		j = 0;
		// ft_printf("### we draw line %d\n\n", i);
		while (j < data->map->width)
		{
			//ft_printf("%d\n", data->map->height);

			// ft_printf("we draw tile [%d.%d]\n", i, j);
			//ft_printf("this is tile %c\n", data->map->map[i][j]);
			if (data->map->map[i][j] == '1')
				draw_tile(j, i, BLUE_PIXEL, data);
			else if (data->map->map[i][j] == '0')
				draw_tile(j, i, WHITE_PIXEL, data);
			else
				draw_tile(j, i, RED_PIXEL, data);
			j++;
		}
		i++;
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/06 12:43:25 by codespace         #+#    #+#             */
/*   Updated: 2024/06/06 13:11:41 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void    ft_error(char *msg)
{
	ft_putstr_fd("Error\n", 2);
	ft_putstr_fd(msg, 2);
	ft_putstr_fd("\n", 2);
}

static void	delete(void *ptr);

void	*garbage_collector(void *ptr, bool clean)
{
	static t_list	*garbage_list;

	if (clean)
	{
		ft_lstclear(&garbage_list, delete);
		return (NULL);
	}
	else
	{
		ft_lstadd_back(&garbage_list, ft_lstnew(ptr));
		return (ptr);
	}
}

static void	delete(void *ptr)
{
	free(ptr);
	ptr = NULL;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_map.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: baptistevieilhescaze <baptistevieilhesc    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/30 13:27:29 by codespace         #+#    #+#             */
/*   Updated: 2024/07/18 15:15:06 by baptistevie      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

t_map	*get_map(char *path)
{
	int	fd;
	int	map_row;
	char	*line;
	t_map	*map;

	map = init_map();
	map->height++;
	get_map_dim(map, path);
	map->map = malloc(sizeof(char *) * map->height);
	if (!map->map)
		ft_error("[get_map(...)] : map->map malloc failed");
	garbage_collector(map->map, false);
	fd = open(path, O_RDONLY);
	if (fd < 0)
		ft_error("[get_map(...)] : opened file returned < 0");
	line = get_next_line(fd);

	map_row = 0;
	while (line)
	{
		if (*line != '\n')
		{
			if (is_texture_line(line))
				get_texture_line(map, line);
			else if (is_map_line(line))
				get_map_line(map, line, &map_row);
		}
		free(line);
		line = get_next_line(fd);
	}
	free(line);
	return (map);
}	

void	get_map_dim(t_map *map, char *path)
{
	int		fd;
	int		height;
	char	*line;

	fd = open(path, O_RDONLY);
	if (fd < 0)
		ft_error("[get_map_dim(...)] : opened file returned < 0");
	ft_printf("starting to get dimensions\nstart height = %d\nstart width %d\n", map->width, map->height); ////////////////
	height = 0;
	ft_printf("before loop : height = %d | map->height = %d\n", height, map->height); //////////////////////
	line = get_next_line(fd);
	while (line)
	{
		if (*line != '\n' && is_map_line(line))
		{
			height++;
			ft_printf("after increment : height = %d | map->height = %d\n", height, map->height); //////////////////////
			if ((int)ft_strlen(line) > map->width)
			{
				map->width = ft_strlen(line);
				ft_printf("new max width = %d\n", map->width); //////////////////////
				ft_printf("after new max : height = %d | map->height = %d\n", height, map->height); //////////////////////
			}
		ft_printf("end of principal if : height = %d | map->height = %d\n", height, map->height); //////////////////////
		}
		free (line);
		line = get_next_line(fd);
		ft_printf("end of while : height = %d | map->height = %d\n", height, map->height); //////////////////////
	}
	free(line);
	ft_printf("(after free(line)) : height = %d | map->height = %d\n", height, map->height); ////////////////////
	map->height = height;
	ft_printf("final width = %d\nfinal height = %d\n\n", map->width, map->height); //////////////////
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_map_utils.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bvieilhe <bvieilhe@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/05/30 14:25:48 by codespace         #+#    #+#             */
/*   Updated: 2024/06/25 18:38:40 by bvieilhe         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

bool	is_texture_line(char *line)
{
	return (ft_strnstr(line, "NO", 2) || ft_strnstr(line, "SO", 2)
			|| ft_strnstr(line, "EA", 2) || ft_strnstr(line, "WE", 2)
			|| ft_strnstr(line, "F", 1) || ft_strnstr(line, "C", 1));
}

bool	is_map_line(char *line)
{
	int	i;

	i = 0;
	while (line[i])
	{
		if (line[i] != '0' && line[i] != ' '
			&& line[i] != '1' && line[i] != 'N'
			&& line[i] != 'S' && line[i] != 'W'
			&& line[i] != 'E' && line[i] != '\n')
			return (false);
		i++;
	}
	return (true);
}

void	get_texture_line(t_map *map, char *line)
{
	if (ft_strnstr(line, "NO", 2))
		map->texture->north_wall = line + 3;
	if (ft_strnstr(line, "SO", 2))
		map->texture->south_wall = line + 3;
	if (ft_strnstr(line, "EA", 2))
		map->texture->east_wall = line + 3;
	if (ft_strnstr(line, "WE", 2))
		map->texture->west_wall = line + 3;
	if (ft_strnstr(line, "C", 1))
		map->texture->ceiling = line + 2;
	if (ft_strnstr(line, "F", 1))
		map->texture->floor = line + 2;
}

void	get_map_line(t_map *map, char *line, int *row)
{
	int	i;

	map->map[*row] = malloc((map->width + 1) * sizeof(char));
	if (!map->map[*row])
		ft_error("[get_map_line(...)] : malloc failed");
	garbage_collector(map->map[*row], false);
	i = 0;
	while (line[i] && i < map->width) // i or i+1 to handle the '\n' ? do we handle when lines are smallest than map->width?
	{
		map->map[*row][i] = line[i];
		i++; 
	}
	map->map[*row][i] = '\0';
	(*row)++;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hooks.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: baptistevieilhescaze <baptistevieilhesc    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/16 17:18:47 by baptistevie       #+#    #+#             */
/*   Updated: 2024/06/16 17:38:31 by baptistevie      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int	handle_no_event(void *data)
{
    /* This function needs to exist, but it is useless for the moment */
	(void) data;
    return (0);
}

int	handle_input(int keysym, t_mlx *data)
{
    if (keysym == XK_Escape)
        mlx_destroy_window(data->mlx_ptr, data->win_ptr);
    return (0);
}

int	handle_keypress(int keysym, t_mlx *data)
{
    if (keysym == XK_Escape)
        mlx_destroy_window(data->mlx_ptr, data->win_ptr);

    ft_printf("Keypress: %d\n", keysym);
    return (0);
}

int	handle_keyrelease(int keysym, void *data)
{
	(void) data;
    ft_printf("Keyrelease: %d\n", keysym);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   img.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bvieilhe <bvieilhe@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/18 15:46:32 by bvieilhe          #+#    #+#             */
/*   Updated: 2024/06/19 16:05:49 by bvieilhe         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

void	img_pix_put(t_img *img, int x, int y, int color)
{
    char    *pixel;
    int		i;

    i = img->bpp - 8;
    pixel = img->addr + (y * img->line_len + x * (img->bpp / 8));
    while (i >= 0)
    {
        if (img->endian != 0)
            *pixel++ = (color >> i) & 0xFF;
        else
            *pixel++ = (color >> (img->bpp - 8 - i)) & 0xFF;
        i -= 8;
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: baptistevieilhescaze <baptistevieilhesc    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/20 17:28:11 by baptistevie       #+#    #+#             */
/*   Updated: 2024/07/18 11:13:55 by baptistevie      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

t_map	*init_map(void)
{
	t_map	*map;

	map = malloc(sizeof(t_map));
	if (!map)
		ft_error("[init_map(...)] : t_map malloc failed");
	garbage_collector(map, false);
	map->height = 0;
	map->width = 0;
	map->texture = malloc(sizeof(t_texture));
	if (!map->texture)
		ft_error("[init_map(...)] : t_texture malloc failed");
	garbage_collector(map->texture, false);
	return (map);
}

t_mlx	*init_mlx(void)
{
	t_mlx	*mlx;

	mlx = malloc(sizeof(t_mlx));
	if (!mlx)
		ft_error("[init_mlx(...)] : t_mlx malloc failed");
	garbage_collector(mlx, false);
	return (mlx);
}

t_img	init_img(void)
{
	t_img	image;

	// image = malloc(sizeof(t_img));
	// if (!image)
	// 	ft_error("[init_img(...)] : t_img malloc failed");
	// garbage_collector(image, false);
	image.mlx_img = NULL;
	image.addr = NULL;
	image.bpp = 0;
	image.line_len = 0;
	image.endian = 0;
	return (image);
}

t_game	*init_game(void)
{
	t_game	*game;

	game = malloc(sizeof(t_game));
	if (!game)
		ft_error("[init_game(...)] : t_game malloc failed");
	garbage_collector(game, false);
	game->map = init_map();
	game->mlx = init_mlx();
	game->img = init_img();
	return (game);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: baptistevieilhescaze <baptistevieilhesc    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/28 19:36:50 by codespace         #+#    #+#             */
/*   Updated: 2024/07/18 14:13:39 by baptistevie      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

// /*********************** TESTING FUNCTIONS *******************/

void    print_map(t_map *map)
{
    int i;

    i = 0;
    ft_printf("printing map...\nWIDTH = %d\nHEIGHT = %d\n", map->width, map->height);
    while (i < map->height)
    {
        ft_printf(map->map[i]);
        i++;
    }
    ft_printf("\n");
}

// void    print_texture(t_texture *texture)
// {
//     ft_printf("NO = %s", texture->north_wall);
//     ft_printf("SO = %s", texture->south_wall);
//     ft_printf("EA = %s", texture->east_wall);
//     ft_printf("WE = %s", texture->west_wall);
//     ft_printf("C = %s", texture->ceiling);
//     ft_printf("F = %s", texture->floor);
// }


// /************************** MAIN *****************************/


// int main(int ac, char **av)
// {
//     t_map   map;

//     if (ac == 2)
//     {
//         map = *(get_map(av[1]));
//         print_map(&map);
//         print_texture(map.texture);
//     }
//     return (1);
// }

#define MLX_ERROR 1

void	render_background(t_img *img, int color)
{
    int	i;
    int	j;

    i = 0;
    while (i < WINDOW_HEIGHT)
    {
        j = 0;
        while (j < WINDOW_WIDTH)
        {
            img_pix_put(img, j++, i, color);
        }
        ++i;
    }
}

int	main(int ac, char **av)
{
    t_game	*data;

    data = init_game();
    if (ac != 2)
        return (0);

    data->mlx->mlx_ptr = mlx_init();
    if (data->mlx->mlx_ptr == NULL)
        return (MLX_ERROR);
    data->mlx->win_ptr = mlx_new_window(data->mlx->mlx_ptr, WINDOW_WIDTH, WINDOW_HEIGHT, "cub3d");
    if (data->mlx->win_ptr == NULL)
    {
        free(data->mlx->win_ptr);
        return (MLX_ERROR);
    }

    data->map = get_map(av[1]);
    print_map(data->map); //test
	check_map(data->map);
    data->img.mlx_img = mlx_new_image(data->mlx->mlx_ptr, WINDOW_WIDTH, WINDOW_HEIGHT);
	data->img.addr = mlx_get_data_addr(data->img.mlx_img, &data->img.bpp,
			&data->img.line_len, &data->img.endian);

    /* Setup hooks */ 
    mlx_loop_hook(data->mlx->mlx_ptr, &render_2d, data);
    mlx_hook(data->mlx->win_ptr, KeyPress, KeyPressMask, &handle_keypress, data);
    mlx_hook(data->mlx->win_ptr, KeyRelease, KeyReleaseMask, &handle_keyrelease, data);

    mlx_loop(data->mlx->mlx_ptr);

    /* we will exit the loop if there's no window left, and execute this code */
    mlx_destroy_display(data->mlx->mlx_ptr);
    free(data->mlx->mlx_ptr);

    return (1);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bvieilhe <bvieilhe@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/19 16:26:37 by bvieilhe          #+#    #+#             */
/*   Updated: 2024/07/12 15:03:47 by bvieilhe         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

int render_2d(t_game *data)
{
	draw_map(data);
	mlx_put_image_to_window(data->mlx->mlx_ptr, data->mlx->win_ptr,
							data->img.mlx_img, 0, 0);
	return (0);
}
